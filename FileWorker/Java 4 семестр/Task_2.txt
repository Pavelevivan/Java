Вторая задача по практике ООП - 4 семестр - 2018г.



Цель данного упражнения познакомить студента с особенностями многопоточного программирования в Java\С#, 
а также сконструировать модуль для дальнейшей работы. В рамках выполнения упражнения необходимо учесть механизмы 
синхронизации и обспечение монопольного доступа. Далее задача формулируется для Java.



1. Необходимо написать класс-singleton ThreadDispatcher. Данный класс представляет собой диспетчер потоков, который 
	способен ставить задачи на параллельное выполнение. Класс содержит следующий метод:

		public void Add(ThreadedTask task) - данный метод запускает на выполнение задачу.

	ThreadedTask - абстрактный базовый класс, реализующий интерфейс Runnable. Runnable - интерфейс Java, позволяющий 
	выполнять код многопоточно. Соотвественно, чтобы создать определенную 	задачу, необходимо отнаследоваться от 
	ThreadedTask и переопределить метод run:

	class SleepWorker extends ThreadedTask 
	{
		public void run()
		{
			Thread.sleep(10000);
		}
	}

		Класс SleepWorker представляет собой пример задачи параллельного выполнения. В данном случае в отдельном 
		потоке будет выполено тело метода run() - поток заснет на 10 секунд. Затем завершится. Таким образом, порождая 
		наследников ThreadedTask и переопределяя метод run() возможно создание произвольных задач для параллельного 
		выполнения.

2. При создании объекта ThreadDispatcher необходимо в конструкторе вызвать метод 
		
		void Add(ThreadedTask task) - где аргументом task должен быть экземпляр класс ThreadMonitor, являющийся 
		наследником ThreadedTask. То есть при создании диспетчера потоков по умолчанию сразу же создается фоновый поток. 

	ThreadMonitor - класс, реализующий функциональность монитора потоков. Необходимо с его помощью в методе 	
		run() 	реализовать вывод в файл списка запущенных потоков и их идентификаторов. Соотвественно, как только поток 	
	завершился, список монитора потоков должен обновиться, и данный поток должен исчезнуть. При запуске потока - поток 
		должен добавиться в вывод. Подобное поведение можно наблюдать в диспетчере задач в Windows. Монитор потоков 
			работает столько, сколько существует singleton ThreadedTask. Не может отключаться или ставиться на паузу. Монитор 
		всегда показывает актуальное состояние диспетчера потоков.

	ВАЖНО: необходимо реализовать именно отображение в реальном времени списка запущенных потоков, а не бесконечный 
	вывод актуального состояния в файл. 

      *. Реализовать вызов callback-функции при завершении метода run(). То есть необходимо сделать механизм оповещения от 
		потока к диспетчеру о том, что поток готовится к завршению.


